#include <iostream>
#include <iomanip>
#include <string>
#include <cstdlib>

using namespace std;

/**
Структура для моделирования матрицы чисел. Изначально содержит пустую матрицу (rows=cols=0).
Для создания матрицы нужно передать экземляр структуры в функцию Create(),
а для удаления - в Delete().

Для работы с матрицей нужно обращаться к полю m. Например, как-то так:
Matrix test;
Create(test, 2, 3);
test.m[0][0] = 10;

А можно и просто писать test[0][0] (ведь это логично, ведь Matrix - это модель матрицы)
благодаря строке double*& operator[](int row) - см. ниже
*/
struct Matrix
{
    // Задаём значения по умолчанию, чтобы новосозданные переменные типа Matrix моделировали пустую матрицу,
    // а не содержали мусор

    /// Данные матрицы в динамической памяти.
    /// Это один массив из rows указателей, а также rows массивов из colls чисел типа double.
    double** m = nullptr; // nullptr - специальное обозначение нулевого указателя, можно считать, что это просто 0.
    /// количество строк
    int rows = 0;
    /// количество столбцов
    int cols = 0;

    /**
    Переопределение оператора [].

    Рассмотрим пример:
    Matrix s;
    s.rows = 10; // это компилятору понятно - берём поле rows и пишем в него 10
    s[0] = new double[10] - а вот это не понятно, т.к. s - не массив, а структура.

    В приведённой ниже функции мы объясняем, что в этом случае (s[0]) делать - нужно просто обращаться к полю m:
    s[<some_number>] надо понимать как s.m[<some_number>], т.е. по сути надо вернуть
    указатель на соответствующую строку матрицы

    А к этому указателю уже можно ещё раз применить [] - так мы получим элемент строки.
    Т.е. s[0][0] = 10  <--> s.m[0][0].
    */
    double*& operator[](int row)
    {
        // возвращаем указатель на массив, соответствующий строке под номером row.
        // Возврат у нас по ссылке (см. заголовок функции), следовательно вернётся не просто значение указателя (копия),
        // а сама область памяти массива m, в которой хранится этот указатель.
        // Это позволяет делать присваивание, например s[0] = new double*[10] <--> s.m[0] = new double*[10]
        return m[row];
    }
};

/**
Проверяет, лежит ли в arr пустая матрица.
*/
bool IsEmpty(Matrix& arr)
{
    /// Должна возвращать true, если к arr была применена функция Delete() либо ещё не была применена Create()
    return arr.m == nullptr;
}

/**
Создаёт в arr матрицу заданных размеров и возвращает true, но только если до этого
в arr лежала пустая матрица (IsEmpty(arr) == true).
Иначе ничего не делает и возвращает false.
*/
bool Create(Matrix& arr, int rows, int cols)
{
    //TODO реализация неправильная

    /// TODO

    if(IsEmpty(arr) == true)
    {
        arr.m = new double*[rows];

        for(int i=0; i<cols; i++)
        {
            arr.m[i] = new double[cols];
        }

        arr.rows = rows;
        arr.cols = cols;
        return true;
    }
    else
    {
        return false;
    }
}


/**
Функция, возвращающая пустую матрицу. Полезна для явного выделения в коде мест, где это необходимо сделать.
*/
Matrix CreateEmptyMatrix()
{
    return Matrix(); // по умолчанию и создаётся пустая матрица - её и возвращаем.
}

/**
Удаляет матрицу из структуры arr, так что в arr теперь будет пустая матрица (IsEmpty(arr) == true)
*/
void Delete(Matrix& arr)
{
    // TODO

    /// После удаления нужно привести переданный arr к состоянию пустой матрицы, чтобы стало IsEmpty(arr) == true.


    for(int i=0; i<arr.rows; i++)
        {
            delete[] arr[i];
        }

       delete[] arr.m;

       arr=CreateEmptyMatrix();


}

/**
Заполняет матрицу нулями
*/
void FillZero(Matrix& arr)
{
    // Для пустой матрицы цикл ни разу не выполнится, так что можно отдельно не проверять IsEmpty().
    for(int i=0; i < arr.rows; i++)
    {
        for(int j=0; j< arr.cols; j++)
        {
            arr[i][j] = 0;
        }
    }
}

/**
Выводит матрицу на экран
*/
void Print(Matrix& arr)
{
    for(int i=0; i < arr.rows; i++)
    {
        for(int j=0; j< arr.cols; j++)
        {
            // setw - на следующий выводимый элемент выделяем 8 символов
            // setprecision - просим следующее число уместить в 5 цифр
            // зазор в 3 символа - для -0.<5 значащих цифр>
            cout << setw(8) << setprecision(5) << arr[i][j] << " ";
        }

        cout << endl;
    }
}

int main()
{
    Matrix arr;
    Create(arr, 3, 4);
    arr[0][0] = 4;
    arr[0][1] = 5;
    arr[0][2] = 2;
    arr[0][3] = 1;

    arr[1][0] = 3;
    arr[1][1] = -3;
    arr[1][2] = 2;
    arr[1][3] = 2;

    arr[2][0] = 2;
    arr[2][1] = -3;
    arr[2][2] = 1;
    arr[2][3] = 3;

    Print(arr);

    Delete(arr);

    return 0;
}
